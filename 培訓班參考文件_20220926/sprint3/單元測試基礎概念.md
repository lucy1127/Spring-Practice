---
tags: Java
---

# 單元測試基礎概念

## 前言

撰寫測試是開發專案時不可或缺的一部分，好的測試不但不會拖慢開發速度還能降低維護成本，本篇將焦點聚集在單元測試，介紹基本概念、規則以及專案實作。

## 目錄

* [單元測試基礎概念](#單元測試基礎概念)
  * [前言](#前言)
  * [目錄](#目錄)
  * [介紹/基本概念](#介紹基本概念)
    * [單元測試](#單元測試)
    * [3A 原則](#3A-原則)
    * [常用函式庫](#常用函式庫)
  * [應用情境說明](#應用情境說明)
  * [建置環境](#建置環境)
  * [實作過程](#實作過程)
    * [Repository 單元測試](#Repository-單元測試)
    * [Service 單元測試](#Service-單元測試)
    * [Controller 單元測試](#Controller-單元測試)
    * [static 和 private 方法](#static-和-private-方法)
    * [測試](#測試)
  * [參考資料](#參考資料)
  * [撰寫紀錄](#撰寫紀錄)

## 介紹/基本概念

### 單元測試

單元測試 *Unit Test*，又稱為模組測試，是指針對程式的最小單位（一個方法）進行正確性檢驗，每個測試之間具有隔離性，確保每個單元獨立運作時沒有錯誤，未來單元間組合在一起時出錯率下降也方便偵錯。

由於測試時需要與其他單元無關，所以經常使用 mock、fake 等假物件，以免測試過程中被影響測試結果

### 3A 原則

3A 原則，分別是 Arrange（初始化）、Act（行為）、Assert（驗證結果），撰寫測試案例時會遵循此原則，使測試格式標準化

### 常用函式庫

* JUnit：Ｊava application 標準
* SpringBootTest：提供了對 Spring Boot 應用程式的支持
* AssertJ：斷言函式庫
* Hamcrest：匹配器對象函式庫
* JSONassert：JSON 斷言函式庫
* JSONPath：用於 JSON 的 Xpath 函式庫

## 應用情境說明

單元測試於任何專案上都能進行，此次應用情境為標準 MVC 架構下，分別對 Service、Controller、Repository 撰寫單元測試

## 建置環境

1. 根據 [Spring DATA JPA](https://hackmd.io/@kazzy/rk8_4jqj5/https%3A%2F%2Fhackmd.io%2F%40laurence60025%2FBy9qEHCiq#%E5%AF%A6%E4%BD%9C%E9%81%8E%E7%A8%8B) 建置一個專案

2. 創建單元測試
   * 假設要創建 StaffService.java 的單元測試，通常會創建和它相同的路徑的 package
   ![例 1](https://i.imgur.com/GY8EA1V.png)

   * 右鍵 package -> new -> other -> Java -> JUnit -> JUnit Test Case
   ![例 2](https://i.imgur.com/WoD442R.png)
   ![例 3](https://i.imgur.com/okGQnRd.png)

   * 選 New JUnit 4 test，Name 為所測試的元件的名稱 + Test，完成後 finish
   ![例 4](https://i.imgur.com/8jJ4K17.png/minion.png )

3. 以下圖結構創建專案
   ![例 5](https://i.imgur.com/XKy6GQo.png)

4. 在資料庫中創建一筆資料
   * name = testName
   * age = 25
   * id = 1
   * 其餘欄位為 null

## 實作過程

### Repository 單元測試

#### StaffRepositoryTest.java

```java=
import org.assertj.core.api.Assertions;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import com.example.demo.UnitTestDemoApplication;
import com.example.demo.entity.Staff;

// 讓測試運行於 Spring 測試環境
@RunWith(SpringRunner.class)
// 獲取啟動主程式、加載配置，確定啟用 Spring Boot
@SpringBootTest(classes = UnitTestDemoApplication.class)
public class StaffRepositoryTest {

    @Autowired
    private StaffRepository repository;

    // 有 @Test 的 function 才會在 JUnit Test 時被執行
    @Test
    public void findByNameTest() {

      // Arrange (初始化)，設定參數、期望回傳值
      String expected = "testName";

      // Act (行為)，取得 function 的實際回傳值
      Staff actual = repository.findByName("testName");

      // Assert (驗證結果)
      // JUnit 原生寫法
      Assert.assertEquals(expected, actual.getName());

      // AssertJ 寫法
      Assertions.assertThat(actual.getName()).isEqualTo(expected);
    }
}
```

### Service 單元測試

#### StaffServiceTest.java

```java=
import static org.mockito.Mockito.when;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit4.SpringRunner;
import com.example.demo.UnitTestDemoApplication;
import com.example.demo.entity.Staff;
import com.example.demo.repository.StaffRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = UnitTestDemoApplication.class)
public class StaffServiceTest {

    @Autowired
    private StaffService service;

    // 利用 mock 技術模擬出對資料庫連結的物件
    @MockBean
    private StaffRepository repository;

    @Test
    public void findByNameTest() throws JsonProcessingException {

        // Arrange (初始化)
        String name = "testName";
        Staff expected = new Staff(name, 50L, null, null);
        expected.setId(3L);

        // 將 object 轉成 JSON
        ObjectMapper om = new ObjectMapper();
        String expectedStr = om.writeValueAsString(expected);

        // 當程式執行到 findByName() 並帶入 name 參數時，則回傳 expected 物件，不會實際執行 function
        // 若不限制接收的參數時，可將 name 改為 any()
        when(repository.findByName(name)).thenReturn(expected);

        // Act (行為)
        Staff actual = service.findByName(name);
        String actualStr = om.writeValueAsString(actual);

        // Assert (驗證結果)
        Assert.assertEquals(expectedStr, actualStr);
    }
}
```

### Controller 單元測試

#### StaffControllerTest.java

```java=
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import com.example.demo.UnitTestDemoApplication;
import com.example.demo.entity.Staff;
import com.example.demo.service.StaffService;
import com.fasterxml.jackson.databind.ObjectMapper;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = UnitTestDemoApplication.class)
public class StaffControllerTest {

    // 測試 Controller 需要建立假的 MVC 環境
    private MockMvc mockMvc;

    @Autowired
    private StaffController controller;

    // 使用 MockBean 製作假元件
    @MockBean
    private StaffService service;

    // before 的 function 會在一開始比 Test 先執行
    @Before
    public void setup() throws Exception {

        // standaloneSetup 表示通過參數指定一組控制器，這樣就不需要從上下文獲取
        mockMvc = MockMvcBuilders.standaloneSetup(controller).build();
    }

    @Test
        public void search() throws Exception {
        // Arrange (初始化)
        String name = "testName1";
        Long age = 50L, id = 3L;
        Staff expected = new Staff(name, age, null, null);
        expected.setId(id);
        // mocking
        when(this.service.findByName(any())).thenReturn(expected);
        // 將 object 轉為 JSON 的格式
        ObjectMapper om = new ObjectMapper();
        String expectedStr = om.writeValueAsString(expected);
        // Act (行為)
        ResultActions resultActions =
                // perform(request) 為做一個請求的建立，get(url) 為 request 的連結
                mockMvc.perform(
                        MockMvcRequestBuilders.get("/api/findByName/" + name).contentType(MediaType.APPLICATION_JSON))
                        // 輸出整個回應結果訊息
                        .andDo(print())
                        // Assert (驗證結果)
                        // 驗證回傳的 http 狀態和 response body 的 json 格式中的 name 欄位是否正確
                        .andExpect(status().isOk()).andExpect(jsonPath("name", is(expected.getName())));
        // 取得回傳物件
        String actual = resultActions.andReturn().getResponse().getContentAsString();
        Assert.assertEquals(expectedStr, actual);
    }
}
```

#### ResultActions 用法

* 將 MockMvcRequestBuilders.get 改為 post、update、delete、put 可改為其他請求
* get(URL)，URL 為 API 的路徑

```java
mockMvc.perform(MockMvcRequestBuilders.get("/api/findByName/" + name)
```

* 若 request 有 body 可使用 content() 新增 JSON 格式的資料

```java
mockMvc.perform().content(om.writeValueAsString( object ))
```

* 若有 Param 可使用 param(參數名稱，參數值) 新增

```java
mockMvc.perform().param("id", id)
```

### static 和 private 方法

1. 在 pom.xml 新增依賴，新增完右鍵專案 maven -> update project

   ```java
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-inline</artifactId>
        <scope>test</scope>
    </dependency>
   ```

2. 在 src/main/java 的 com.example.demo.service 新增 UnitTestDemoService.java

    ```java=
    import org.springframework.stereotype.Service;

    @Service
    public class UnitTestDemoService {

        private String privateFunction(String str,Long id) {
            return str;
        }

        static public String staticFunction(String str) {
            return str;
        }
    }
    ```

3. 在 src/test/java 的 com.example.demo.service 新增 UnitTestDemoServiceTest.java

    ```java=
    import static org.junit.Assert.assertEquals;
    import static org.mockito.ArgumentMatchers.any;

    import java.lang.reflect.InvocationTargetException;
    import java.lang.reflect.Method;
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.mockito.MockedStatic;
    import org.mockito.Mockito;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.context.junit4.SpringRunner;
    import com.example.demo.UnitTestDemoApplication;

    @RunWith(SpringRunner.class)
    @SpringBootTest(classes = UnitTestDemoApplication.class)
    public class UnitTestDemoServiceTest {

        @Autowired
        private UnitTestDemoService service;

        @Test
        // 測試 private 方法
        public void privateFunctionTest() throws IllegalAccessException, IllegalArgumentException,
                InvocationTargetException, NoSuchMethodException, 
                SecurityException, ClassNotFoundException {
            String expected = "private";
            // 取得 class
            Class<?> clazz = Class.forName("com.example.demo.service.UnitTestDemoService");
            // 取得方法，第一個參數為 function 的名稱，方法有幾個參數後面就有幾個相對應的參數型態
            Method method = clazz.getDeclaredMethod("privateFunction", 
                String.class, Long.class);
            // 將 private method 改成 accessible
            method.setAccessible(true);
            // 調用方法取得回傳值
            String response = method.invoke(service, expected, 10L).toString();
            assertEquals(expected, response);
        }

        @Test
        // mock static 方法
        public void staticFunctionTest() {
            // 使用 MockedStatic 製作假元件
            MockedStatic<UnitTestDemoService> mocked = Mockito.mockStatic(UnitTestDemoService.class);
            String response;
            // 當沒有設定回傳值時，回傳值為 null
            response = UnitTestDemoService.staticFunction("static");
            assertEquals(null, response);
            // 設定 function 的回傳值
            mocked.when(() -> UnitTestDemoService.staticFunction(any())).thenReturn("static");
            response = UnitTestDemoService.staticFunction("test");
            assertEquals("static", response);
        }
    }
    ```

### 測試

1. 右鍵 Run As -> JUnit Test
   ![例 6](https://i.imgur.com/kvvROs9.png)

2. 出現下圖代表測試成功
   ![例 7](https://i.imgur.com/jYCxvBR.png)

   * 若出現下圖，檢查 Test runner 是否為 JUnit 4
     ![例 8](https://i.imgur.com/VXoLq56.png)

     * 右鍵 Run As -> Run Configurations -> Apply -> Run
     ![例 9](https://i.imgur.com/scsM3ov.png)
     ![例 10](https://i.imgur.com/83d0SAk.png)

3. 出現 Failures 代表驗證不成功
   ![例 11](https://i.imgur.com/Vl3XRne.png)

4. 出現 Errors 代表程式出錯
   ![例 12](https://i.imgur.com/gM68N8W.png)

## 參考資料

* [Day 21 Spring Boot 單元測試 (Unit Test)](https://ithelp.ithome.com.tw/articles/10196471)
* [Day 22 Spring Boot 單元測試 (Unit Test)-MockMvc 框架介紹](https://ithelp.ithome.com.tw/articles/10196729)
* [Spring Boot 的單元測試](https://www.tpisoftware.com/tpu/articleDetails/1256)

## 撰寫紀錄

| 人員 | 日期 | 修改紀錄 |
| - | - | - |
| 懿修 | 2022/7 | 初版 |
| 鈞昊 | 2022/7 | 初版 |
